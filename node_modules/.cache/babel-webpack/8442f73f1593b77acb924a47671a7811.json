{"ast":null,"code":"'use strict';\n/**\n * @license Angular v12.0.0-next.0\n * (c) 2010-2020 Google LLC. https://angular.io/\n * License: MIT\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/*\n * This is necessary for Chrome and Chrome mobile, to enable\n * things like redefining `createdCallback` on an element.\n */\n\nlet zoneSymbol;\n\nlet _defineProperty;\n\nlet _getOwnPropertyDescriptor;\n\nlet _create;\n\nlet unconfigurablesKey;\n\nfunction propertyPatch() {\n  zoneSymbol = Zone.__symbol__;\n  _defineProperty = Object[zoneSymbol('defineProperty')] = Object.defineProperty;\n  _getOwnPropertyDescriptor = Object[zoneSymbol('getOwnPropertyDescriptor')] = Object.getOwnPropertyDescriptor;\n  _create = Object.create;\n  unconfigurablesKey = zoneSymbol('unconfigurables');\n\n  Object.defineProperty = function (obj, prop, desc) {\n    if (isUnconfigurable(obj, prop)) {\n      throw new TypeError('Cannot assign to read only property \\'' + prop + '\\' of ' + obj);\n    }\n\n    const originalConfigurableFlag = desc.configurable;\n\n    if (prop !== 'prototype') {\n      desc = rewriteDescriptor(obj, prop, desc);\n    }\n\n    return _tryDefineProperty(obj, prop, desc, originalConfigurableFlag);\n  };\n\n  Object.defineProperties = function (obj, props) {\n    Object.keys(props).forEach(function (prop) {\n      Object.defineProperty(obj, prop, props[prop]);\n    });\n    return obj;\n  };\n\n  Object.create = function (obj, proto) {\n    if (typeof proto === 'object' && !Object.isFrozen(proto)) {\n      Object.keys(proto).forEach(function (prop) {\n        proto[prop] = rewriteDescriptor(obj, prop, proto[prop]);\n      });\n    }\n\n    return _create(obj, proto);\n  };\n\n  Object.getOwnPropertyDescriptor = function (obj, prop) {\n    const desc = _getOwnPropertyDescriptor(obj, prop);\n\n    if (desc && isUnconfigurable(obj, prop)) {\n      desc.configurable = false;\n    }\n\n    return desc;\n  };\n}\n\nfunction _redefineProperty(obj, prop, desc) {\n  const originalConfigurableFlag = desc.configurable;\n  desc = rewriteDescriptor(obj, prop, desc);\n  return _tryDefineProperty(obj, prop, desc, originalConfigurableFlag);\n}\n\nfunction isUnconfigurable(obj, prop) {\n  return obj && obj[unconfigurablesKey] && obj[unconfigurablesKey][prop];\n}\n\nfunction rewriteDescriptor(obj, prop, desc) {\n  // issue-927, if the desc is frozen, don't try to change the desc\n  if (!Object.isFrozen(desc)) {\n    desc.configurable = true;\n  }\n\n  if (!desc.configurable) {\n    // issue-927, if the obj is frozen, don't try to set the desc to obj\n    if (!obj[unconfigurablesKey] && !Object.isFrozen(obj)) {\n      _defineProperty(obj, unconfigurablesKey, {\n        writable: true,\n        value: {}\n      });\n    }\n\n    if (obj[unconfigurablesKey]) {\n      obj[unconfigurablesKey][prop] = true;\n    }\n  }\n\n  return desc;\n}\n\nfunction _tryDefineProperty(obj, prop, desc, originalConfigurableFlag) {\n  try {\n    return _defineProperty(obj, prop, desc);\n  } catch (error) {\n    if (desc.configurable) {\n      // In case of errors, when the configurable flag was likely set by rewriteDescriptor(), let's\n      // retry with the original flag value\n      if (typeof originalConfigurableFlag == 'undefined') {\n        delete desc.configurable;\n      } else {\n        desc.configurable = originalConfigurableFlag;\n      }\n\n      try {\n        return _defineProperty(obj, prop, desc);\n      } catch (error) {\n        let swallowError = false;\n\n        if (prop === 'createdCallback' || prop === 'attachedCallback' || prop === 'detachedCallback' || prop === 'attributeChangedCallback') {\n          // We only swallow the error in registerElement patch\n          // this is the work around since some applications\n          // fail if we throw the error\n          swallowError = true;\n        }\n\n        if (!swallowError) {\n          throw error;\n        } // TODO: @JiaLiPassion, Some application such as `registerElement` patch\n        // still need to swallow the error, in the future after these applications\n        // are updated, the following logic can be removed.\n\n\n        let descJson = null;\n\n        try {\n          descJson = JSON.stringify(desc);\n        } catch (error) {\n          descJson = desc.toString();\n        }\n\n        console.log(`Attempting to configure '${prop}' with descriptor '${descJson}' on object '${obj}' and got error, giving up: ${error}`);\n      }\n    } else {\n      throw error;\n    }\n  }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nfunction eventTargetLegacyPatch(_global, api) {\n  const {\n    eventNames,\n    globalSources,\n    zoneSymbolEventNames,\n    TRUE_STR,\n    FALSE_STR,\n    ZONE_SYMBOL_PREFIX\n  } = api.getGlobalObjects();\n  const WTF_ISSUE_555 = 'Anchor,Area,Audio,BR,Base,BaseFont,Body,Button,Canvas,Content,DList,Directory,Div,Embed,FieldSet,Font,Form,Frame,FrameSet,HR,Head,Heading,Html,IFrame,Image,Input,Keygen,LI,Label,Legend,Link,Map,Marquee,Media,Menu,Meta,Meter,Mod,OList,Object,OptGroup,Option,Output,Paragraph,Pre,Progress,Quote,Script,Select,Source,Span,Style,TableCaption,TableCell,TableCol,Table,TableRow,TableSection,TextArea,Title,Track,UList,Unknown,Video';\n  const NO_EVENT_TARGET = 'ApplicationCache,EventSource,FileReader,InputMethodContext,MediaController,MessagePort,Node,Performance,SVGElementInstance,SharedWorker,TextTrack,TextTrackCue,TextTrackList,WebKitNamedFlow,Window,Worker,WorkerGlobalScope,XMLHttpRequest,XMLHttpRequestEventTarget,XMLHttpRequestUpload,IDBRequest,IDBOpenDBRequest,IDBDatabase,IDBTransaction,IDBCursor,DBIndex,WebSocket'.split(',');\n  const EVENT_TARGET = 'EventTarget';\n  let apis = [];\n  const isWtf = _global['wtf'];\n  const WTF_ISSUE_555_ARRAY = WTF_ISSUE_555.split(',');\n\n  if (isWtf) {\n    // Workaround for: https://github.com/google/tracing-framework/issues/555\n    apis = WTF_ISSUE_555_ARRAY.map(v => 'HTML' + v + 'Element').concat(NO_EVENT_TARGET);\n  } else if (_global[EVENT_TARGET]) {\n    apis.push(EVENT_TARGET);\n  } else {\n    // Note: EventTarget is not available in all browsers,\n    // if it's not available, we instead patch the APIs in the IDL that inherit from EventTarget\n    apis = NO_EVENT_TARGET;\n  }\n\n  const isDisableIECheck = _global['__Zone_disable_IE_check'] || false;\n  const isEnableCrossContextCheck = _global['__Zone_enable_cross_context_check'] || false;\n  const ieOrEdge = api.isIEOrEdge();\n  const ADD_EVENT_LISTENER_SOURCE = '.addEventListener:';\n  const FUNCTION_WRAPPER = '[object FunctionWrapper]';\n  const BROWSER_TOOLS = 'function __BROWSERTOOLS_CONSOLE_SAFEFUNC() { [native code] }';\n  const pointerEventsMap = {\n    'MSPointerCancel': 'pointercancel',\n    'MSPointerDown': 'pointerdown',\n    'MSPointerEnter': 'pointerenter',\n    'MSPointerHover': 'pointerhover',\n    'MSPointerLeave': 'pointerleave',\n    'MSPointerMove': 'pointermove',\n    'MSPointerOut': 'pointerout',\n    'MSPointerOver': 'pointerover',\n    'MSPointerUp': 'pointerup'\n  }; //  predefine all __zone_symbol__ + eventName + true/false string\n\n  for (let i = 0; i < eventNames.length; i++) {\n    const eventName = eventNames[i];\n    const falseEventName = eventName + FALSE_STR;\n    const trueEventName = eventName + TRUE_STR;\n    const symbol = ZONE_SYMBOL_PREFIX + falseEventName;\n    const symbolCapture = ZONE_SYMBOL_PREFIX + trueEventName;\n    zoneSymbolEventNames[eventName] = {};\n    zoneSymbolEventNames[eventName][FALSE_STR] = symbol;\n    zoneSymbolEventNames[eventName][TRUE_STR] = symbolCapture;\n  } //  predefine all task.source string\n\n\n  for (let i = 0; i < WTF_ISSUE_555_ARRAY.length; i++) {\n    const target = WTF_ISSUE_555_ARRAY[i];\n    const targets = globalSources[target] = {};\n\n    for (let j = 0; j < eventNames.length; j++) {\n      const eventName = eventNames[j];\n      targets[eventName] = target + ADD_EVENT_LISTENER_SOURCE + eventName;\n    }\n  }\n\n  const checkIEAndCrossContext = function (nativeDelegate, delegate, target, args) {\n    if (!isDisableIECheck && ieOrEdge) {\n      if (isEnableCrossContextCheck) {\n        try {\n          const testString = delegate.toString();\n\n          if (testString === FUNCTION_WRAPPER || testString == BROWSER_TOOLS) {\n            nativeDelegate.apply(target, args);\n            return false;\n          }\n        } catch (error) {\n          nativeDelegate.apply(target, args);\n          return false;\n        }\n      } else {\n        const testString = delegate.toString();\n\n        if (testString === FUNCTION_WRAPPER || testString == BROWSER_TOOLS) {\n          nativeDelegate.apply(target, args);\n          return false;\n        }\n      }\n    } else if (isEnableCrossContextCheck) {\n      try {\n        delegate.toString();\n      } catch (error) {\n        nativeDelegate.apply(target, args);\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  const apiTypes = [];\n\n  for (let i = 0; i < apis.length; i++) {\n    const type = _global[apis[i]];\n    apiTypes.push(type && type.prototype);\n  } // vh is validateHandler to check event handler\n  // is valid or not(for security check)\n\n\n  api.patchEventTarget(_global, apiTypes, {\n    vh: checkIEAndCrossContext,\n    transferEventName: eventName => {\n      const pointerEventName = pointerEventsMap[eventName];\n      return pointerEventName || eventName;\n    }\n  });\n  Zone[api.symbol('patchEventTarget')] = !!_global[EVENT_TARGET];\n  return true;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// we have to patch the instance since the proto is non-configurable\n\n\nfunction apply(api, _global) {\n  const {\n    ADD_EVENT_LISTENER_STR,\n    REMOVE_EVENT_LISTENER_STR\n  } = api.getGlobalObjects();\n  const WS = _global.WebSocket; // On Safari window.EventTarget doesn't exist so need to patch WS add/removeEventListener\n  // On older Chrome, no need since EventTarget was already patched\n\n  if (!_global.EventTarget) {\n    api.patchEventTarget(_global, [WS.prototype]);\n  }\n\n  _global.WebSocket = function (x, y) {\n    const socket = arguments.length > 1 ? new WS(x, y) : new WS(x);\n    let proxySocket;\n    let proxySocketProto; // Safari 7.0 has non-configurable own 'onmessage' and friends properties on the socket instance\n\n    const onmessageDesc = api.ObjectGetOwnPropertyDescriptor(socket, 'onmessage');\n\n    if (onmessageDesc && onmessageDesc.configurable === false) {\n      proxySocket = api.ObjectCreate(socket); // socket have own property descriptor 'onopen', 'onmessage', 'onclose', 'onerror'\n      // but proxySocket not, so we will keep socket as prototype and pass it to\n      // patchOnProperties method\n\n      proxySocketProto = socket;\n      [ADD_EVENT_LISTENER_STR, REMOVE_EVENT_LISTENER_STR, 'send', 'close'].forEach(function (propName) {\n        proxySocket[propName] = function () {\n          const args = api.ArraySlice.call(arguments);\n\n          if (propName === ADD_EVENT_LISTENER_STR || propName === REMOVE_EVENT_LISTENER_STR) {\n            const eventName = args.length > 0 ? args[0] : undefined;\n\n            if (eventName) {\n              const propertySymbol = Zone.__symbol__('ON_PROPERTY' + eventName);\n\n              socket[propertySymbol] = proxySocket[propertySymbol];\n            }\n          }\n\n          return socket[propName].apply(socket, args);\n        };\n      });\n    } else {\n      // we can patch the real socket\n      proxySocket = socket;\n    }\n\n    api.patchOnProperties(proxySocket, ['close', 'error', 'message', 'open'], proxySocketProto);\n    return proxySocket;\n  };\n\n  const globalWebSocket = _global['WebSocket'];\n\n  for (const prop in WS) {\n    globalWebSocket[prop] = WS[prop];\n  }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nfunction propertyDescriptorLegacyPatch(api, _global) {\n  const {\n    isNode,\n    isMix\n  } = api.getGlobalObjects();\n\n  if (isNode && !isMix) {\n    return;\n  }\n\n  if (!canPatchViaPropertyDescriptor(api, _global)) {\n    const supportsWebSocket = typeof WebSocket !== 'undefined'; // Safari, Android browsers (Jelly Bean)\n\n    patchViaCapturingAllTheEvents(api);\n    api.patchClass('XMLHttpRequest');\n\n    if (supportsWebSocket) {\n      apply(api, _global);\n    }\n\n    Zone[api.symbol('patchEvents')] = true;\n  }\n}\n\nfunction canPatchViaPropertyDescriptor(api, _global) {\n  const {\n    isBrowser,\n    isMix\n  } = api.getGlobalObjects();\n\n  if ((isBrowser || isMix) && !api.ObjectGetOwnPropertyDescriptor(HTMLElement.prototype, 'onclick') && typeof Element !== 'undefined') {\n    // WebKit https://bugs.webkit.org/show_bug.cgi?id=134364\n    // IDL interface attributes are not configurable\n    const desc = api.ObjectGetOwnPropertyDescriptor(Element.prototype, 'onclick');\n    if (desc && !desc.configurable) return false; // try to use onclick to detect whether we can patch via propertyDescriptor\n    // because XMLHttpRequest is not available in service worker\n\n    if (desc) {\n      api.ObjectDefineProperty(Element.prototype, 'onclick', {\n        enumerable: true,\n        configurable: true,\n        get: function () {\n          return true;\n        }\n      });\n      const div = document.createElement('div');\n      const result = !!div.onclick;\n      api.ObjectDefineProperty(Element.prototype, 'onclick', desc);\n      return result;\n    }\n  }\n\n  const XMLHttpRequest = _global['XMLHttpRequest'];\n\n  if (!XMLHttpRequest) {\n    // XMLHttpRequest is not available in service worker\n    return false;\n  }\n\n  const ON_READY_STATE_CHANGE = 'onreadystatechange';\n  const XMLHttpRequestPrototype = XMLHttpRequest.prototype;\n  const xhrDesc = api.ObjectGetOwnPropertyDescriptor(XMLHttpRequestPrototype, ON_READY_STATE_CHANGE); // add enumerable and configurable here because in opera\n  // by default XMLHttpRequest.prototype.onreadystatechange is undefined\n  // without adding enumerable and configurable will cause onreadystatechange\n  // non-configurable\n  // and if XMLHttpRequest.prototype.onreadystatechange is undefined,\n  // we should set a real desc instead a fake one\n\n  if (xhrDesc) {\n    api.ObjectDefineProperty(XMLHttpRequestPrototype, ON_READY_STATE_CHANGE, {\n      enumerable: true,\n      configurable: true,\n      get: function () {\n        return true;\n      }\n    });\n    const req = new XMLHttpRequest();\n    const result = !!req.onreadystatechange; // restore original desc\n\n    api.ObjectDefineProperty(XMLHttpRequestPrototype, ON_READY_STATE_CHANGE, xhrDesc || {});\n    return result;\n  } else {\n    const SYMBOL_FAKE_ONREADYSTATECHANGE = api.symbol('fake');\n    api.ObjectDefineProperty(XMLHttpRequestPrototype, ON_READY_STATE_CHANGE, {\n      enumerable: true,\n      configurable: true,\n      get: function () {\n        return this[SYMBOL_FAKE_ONREADYSTATECHANGE];\n      },\n      set: function (value) {\n        this[SYMBOL_FAKE_ONREADYSTATECHANGE] = value;\n      }\n    });\n    const req = new XMLHttpRequest();\n\n    const detectFunc = () => {};\n\n    req.onreadystatechange = detectFunc;\n    const result = req[SYMBOL_FAKE_ONREADYSTATECHANGE] === detectFunc;\n    req.onreadystatechange = null;\n    return result;\n  }\n} // Whenever any eventListener fires, we check the eventListener target and all parents\n// for `onwhatever` properties and replace them with zone-bound functions\n// - Chrome (for now)\n\n\nfunction patchViaCapturingAllTheEvents(api) {\n  const {\n    eventNames\n  } = api.getGlobalObjects();\n  const unboundKey = api.symbol('unbound');\n\n  for (let i = 0; i < eventNames.length; i++) {\n    const property = eventNames[i];\n    const onproperty = 'on' + property;\n    self.addEventListener(property, function (event) {\n      let elt = event.target,\n          bound,\n          source;\n\n      if (elt) {\n        source = elt.constructor['name'] + '.' + onproperty;\n      } else {\n        source = 'unknown.' + onproperty;\n      }\n\n      while (elt) {\n        if (elt[onproperty] && !elt[onproperty][unboundKey]) {\n          bound = api.wrapWithCurrentZone(elt[onproperty], source);\n          bound[unboundKey] = elt[onproperty];\n          elt[onproperty] = bound;\n        }\n\n        elt = elt.parentElement;\n      }\n    }, true);\n  }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nfunction registerElementPatch(_global, api) {\n  const {\n    isBrowser,\n    isMix\n  } = api.getGlobalObjects();\n\n  if (!isBrowser && !isMix || !('registerElement' in _global.document)) {\n    return;\n  }\n\n  const callbacks = ['createdCallback', 'attachedCallback', 'detachedCallback', 'attributeChangedCallback'];\n  api.patchCallbacks(api, document, 'Document', 'registerElement', callbacks);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n(function (_global) {\n  const symbolPrefix = _global['__Zone_symbol_prefix'] || '__zone_symbol__';\n\n  function __symbol__(name) {\n    return symbolPrefix + name;\n  }\n\n  _global[__symbol__('legacyPatch')] = function () {\n    const Zone = _global['Zone'];\n\n    Zone.__load_patch('defineProperty', (global, Zone, api) => {\n      api._redefineProperty = _redefineProperty;\n      propertyPatch();\n    });\n\n    Zone.__load_patch('registerElement', (global, Zone, api) => {\n      registerElementPatch(global, api);\n    });\n\n    Zone.__load_patch('EventTargetLegacy', (global, Zone, api) => {\n      eventTargetLegacyPatch(global, api);\n      propertyDescriptorLegacyPatch(api, global);\n    });\n  };\n})(typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {});","map":null,"metadata":{},"sourceType":"script"}